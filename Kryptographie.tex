 \documentclass{article} %A4
\usepackage[a4paper,left=1.9cm, right=2.1cm,top = 1.2cm,bottom=2.3cm]{geometry}
\usepackage[utf8]{inputenc}%Umlaute
\usepackage[ngerman]{babel} %Texttrennung
\usepackage{graphicx}	%Grafiken
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{listings}
 \usepackage{color}
\usepackage{hyperref}
\usepackage{framed}
\usepackage{algpseudocode}

\usepackage[labelformat=empty]{caption}
\title{Zusammenfassung - Kryptographie}
\author{
	Marc Meier
}

\begin{document}
\maketitle
\begin{framed}Korrektheit und Vollständigkeit der Informationen sind nicht gewährleistet.
Macht euch eigene Notizen oder ergänzt/korrigiert meine Ausführungen!
\end{framed}
\setcounter{tocdepth}{1}
\tableofcontents

\begin{framed}
Planung der Veranstaltung % Kann später wahrscheinlich ausgelassen werden.
\begin{enumerate}
	\item Wiederholung (ca 3-4 Termine)
	\begin{itemize}
		\item Probleme, Kodierung von Problemen, Laufzeit von Algorithmen
		\item P, PN, NPC…
		\item Grundlegende Probleme \& Algorithmen
	\end{itemize}
	\item Algorithmen für schwierige Probleme (ca. 15 Termine)
	\begin{itemize}
		\item parallele / randomisierte Algorithmen
		\item Approximationsalgorithmen
		\item parametrisierte Algorithmen
	\end{itemize}
	\item Kryptographie (ca 10 Termine)
	\begin{itemize}
		\item Public-Key-Kryptographie
	\end{itemize}
\end{enumerate}
\end{framed}
\section{Grundlagen und Wiederholungen}
\subsection{Probleme, deren Kodierung und Laufzeit von Algorithmen}
Anhand einiger Beispiele soll die Wichtigkeit der Kodierung der Probleme bzw. der Eingabe verdeutlicht werden.
\subsubsection{Sortieren}
\begin{description}
	\item[Eingabemenge:] Natürliche Zahlen $a_1, a_2,...,a_n$
	\item[Ausgabe:] Eingabe aufsteigend sortiert
\end{description}
Beim Sortieren handelt es sich um ein \emph{Suchproblem}.
Beispiele für bekannte Sortieralgorithmen und deren Laufzeitkomplexität sind Bubblesort $\mathcal{O}(n^2)$ und Mergesort $\mathcal{O}(n\log{}n)$\footnote{Sofern nicht anders angegeben entspricht $\log n$ immer dem dualen Logarithmus von n (Basis 2)}.
\subsubsection{Eingabelänge N}
Die Länge der Eingabe entspricht \emph{nicht} der Anzahl der zu sortierenden Elemente $n$.
Dies ist aufgrund der Kodierung in eine maschinenlesbare Form der Fall.
Für gewöhnlich verwenden heutige Computer eine Darstellung im Binärsystem. Daher gilt:
\begin{equation}
N := \sum_{i=1}^n \log a_i
\end{equation}
Im Folgenden soll die Eingabe [11, 13, 113] kodiert werden.
Für eine Turingmaschine mit dem Eingabealphabet $\Sigma := \{0,1,\$ \}$ würde diese folgendermaßen aussehen:
1011\textbf{\$}1101\textbf{\$}1110001.
Um eine Lesbarkeit für Binärrechner zu ermöglichen, werden weiterhin folgende Ersetzungen durchgeführt:
$1 \rightarrow 11$
$0 \rightarrow 00$
$\$ \rightarrow 01$
Die resultierende Kodierung wäre nun:
11001111\textbf{01}11110011\textbf{01}11111100000011.
Sei nun $L$ die maximale Wortlänge\footnote{An dieser Stelle habe ich mit Förmi geschnattert und weiß daher nicht, ob das so korrekt ist}.
\begin{equation}
L := max_{i=1}^n \log a_i
\end{equation}
Hier sollte ergänzt werden, wie man auf das $O(N^3)$ kommt.

\subsubsection{Primzahl}
\begin{description}
	\item[Eingabemenge:] Eine natürliche Zahl $n$
	\item[Ausgabe:] Ist $n$ eine Primzahl? 
\end{description}
Es handelt sich um ein \emph{Entscheidungsproblem}.
Die Eingabelänge ist $N := \log n$.
Ein naiver Algorithmus wird im Folgenden beschrieben.

\begin{algorithmic}[1]
	\If {$n = 2$} \State \Return Ja
	\Else \For {$d:=2$ \textbf{to} $n-1$}
		\If {$n \mod d = 0$}
			\State \Return Nein
		\Else
		\EndIf
	\EndFor
	\State \Return Ja
	\EndIf
\end{algorithmic}

Die Komplexität lässt sich wie folgt herleiten:
Für die Verzweigungen (Zeilen 1 und 5), sowie für die return-Statements in den Zeilen 2 und 6 ist eine beschränkte Komplexität $O(1)$ anzunehmen.
Alle Statements in der for-Schleife werden $n-2$ mal wiederholt, die Komplexität ist $O(n)$.

Die daraus resultierende Komplexität $O(n)$ ist äquivalent zu $O(2^{\log n})$.
Weil $\log n$ der Eingabelänge N entspricht, ist die Komplexität entsprechend $O(2^N)$, also exponentiell.
Demnach ist der Algorithmus nicht effizient.

\subsubsection{Cliquensuche im Graphen}

\begin{framed}
\textbf{CLIQUE}\\
\begin{description}
	\item[Eingabemenge:] Graph $G= (V,E)$ und $k \in N$
	\item[Ausgabe:] Hat G mindestens paarweise verbundene Knoten (eine Clique C mit $\geq k$ Knoten)?
\end{description} 
\end{framed}

\begin{framed}
\textbf{CLIQUE (Suchproblem)}\\
\begin{description}
	\item[Eingabemenge:] Graph $G= (V,E)$
	\item[Ausgabe:] !!!!!!!!!!!!!!ERGÄNZEN!!!!!!!!!!!!!!!!
\end{description} 
\end{framed}

Behauptung: Wenn CLIQUE (Entscheidungsproblem) in polynomieller Zeit lösbar ist, so ist auch die Suchversion von CLIQUE in polynomieller Zeit lösbar.\footnote{In polynomieller Zeit, abhängig von der Knotenzahl |V| des Graphen}

polynomielle Zeit in n = |V| (Knotenzahl des Graphen)

Beweis: 
$\Leftarrow$ 
Zur Eingabe (G,k) von CLIQUE  bestimmen wir zunächst mit dem Alg für CLIQUE-Suchversion eine größte Clique C von G.
Dann vergleiche $|C| \geq k$? Ausgabe JA, falls $|C| \geq k$ sonst NEIN

Laufzeit: Wie Laufzeit für Clique-Suchversion.

$\Rightarrow$
Betrachte folgende Zwischenversion für CLIQUE:
\begin{framed}
CLIQUE-Zwischenversion:
Eingabe: Graph G=(V,E)
Aufgabe: Bestimme die maximalzahl $\omega (G)$\footnote{$\omega(G) = max \{|C|: C ist eine Clique in G\}$ ist die Cliquenzahl} von paarweise verbundenen Knoten in G
\end{framed}

Behauptung: CLIQUE in polyzeit lösbar $\Rightarrow^{(1)}$ CLIQUE-Zwischenversion in polizeit lösbar $\rightarrow^{(2)}$ CLIQUE-Suchversion in polyzeit lösbar.
zu (1): Sei A ein polizeit-Algorithmus für CLIQUE.
Zur Eingabe G von CLIQUE-Zwischenversion wende A auf Eingaben $(G,n), (G,n-1),...,(G,1)$ an!
Ausgabe ist $\omega (G) =$ erstes k mit $A(G,k) = Ja$

\begin{framed}
For k:= n to 1 do
	if A(G,k) = 'ja'
	then return $omega (G) = k $
\end{framed}
Laufzeit: $n \cdot O(n^c) = O(n^{c+1}$


(2): Sei A ein polyzeit Algorithmus für Clique-Zwischenversion.
d.h. $A(G) = \omega (G)$ in $O(n^d)$ für eine Konstante d.

Zur Eingabe G von Clique-Suchversion wende folgendes an:
\begin{framed}
FOR jede Kante $e \in E$ do
	if $\omega (G - e ) = \omega (G)$
	then $G := G - e$
Return C := V(G) ohne isolierte Knoten
\end{framed}

Graph G = (V,E), e = c -- x %clique1.png
a -- b
a -- c
b -- c
c -- d
c --x % fällt weg
x -- y

wird zu G - e = (V, E \\ {e}) %clique2.png

bei G - xy wird y isoliert. %clique3.png

Im Beispiel: $\omega (G) = 3$
G - cx -> $\omega = 3$
G - bc -> $\omega = 2$ %clique4.png


Lösung a -- b -- c = C

Laufzeit: $m \cdot O(n^d) = O(n^{d+2})$

Gegenüberstellung "einfache Formulierung" vs "formale Formulierung"
PRIM: "ist n prim?"
genauer: 
PRIM:
Eingabe: Natürliche Zahl n
Frage: ist n eine Primzahl?

FORMAL: $PRIM = \{ bin(n) |  n \in N ist prim\} \subset {0,1}^+$\footnote{bin(n) - Binärdarstellung von n}
Venn-Diagramm $PRIM \subset \{0,1\}^+$

In der Praxis ermittelt man die Komplexität der Einfachheit halber mit uniformen Kostenmaß.
Sortierung:
Eingabe: $a_1, a_2,...,a_n$ beziehungsweise $bin(a_1) \# bin(a_2) \# ... \# bin(a_n) $ mit Ersetzung 
Aufgabe: Sortiere Zahlen aufsteigend
Mergesort: $O(n \cdot \log n)$
Problem -> Eingabelänge (siehe oben, hatten wir schon)


% Nächster abschnitt
P = Menge aller Entscheidungsprobleme, für die ein (deterministischer) polynomialzeit-Algorithmus existiert (formal via Deterministischer Turing Maschine), "effizient lösbare Probleme"

Ein Optimierungsprolbem ist lösbar, wenn die entsprechende Entscheidungsversion in P ist.

Grundlegende Probleme in P.
\begin{itemize}
\item\textbf{Sortieren}
\item\textbf{PRIM} - Allerdings nicht der vorgestellte Algorithmus. Effizienter Algorithmus wurde 2002 vorgestellt. Komplexität $O(\log n)^{12})$, zur Zeit sogar $O(\log n)^{6})$\url{ https://de.wikipedia.org/wiki/AKS-Primzahltest}
\item\textbf{2-SAT}  (Modellierung mit Graphenproblem für Beweis)
\end{itemize}

\bibliographystyle{alpha}
\bibliography{literatur}
\end{document}